'use strict';
const OutputEndpointData = require("./OutputEndpointData");
const groupBy = require("lodash.groupby");
const sortBy = require("lodash.sortby");
const fs = require("fs");
const yaml = require('js-yaml');
const groupFileNames = {};
function loadEndpointsFromCamelFiles(folder, callback, storeGroupFilePaths = true) {
    const contents = fs.readdirSync(folder);
    contents.forEach(fileName => {
        if (fileName.endsWith('.yaml') && !fileName.startsWith('custom.')) {
            const group = yaml.load(fs.readFileSync(folder + '/' + fileName));
            if (storeGroupFilePaths) {
                groupFileNames[group['name']] = fileName;
            }
            callback(group);
        }
    });
}
module.exports = {
    camelDir: ".scribe/endpoints",
    cacheDir: ".scribe/endpoints.cache",
    groupFileNames,
    async writeEndpointsToDisk(groupedEndpoints) {
        if (fs.existsSync(this.camelDir)) {
            const oldFiles = fs.readdirSync(this.camelDir);
            oldFiles.forEach(f => {
                if (!f.startsWith('custom.')) {
                    fs.unlinkSync(this.camelDir + `/${f}`);
                }
            });
        }
        else {
            fs.mkdirSync(this.camelDir, { recursive: true });
        }
        if (fs.existsSync(this.cacheDir)) {
            // TODO change to only fs.rmSync when we drop support for Node.js < 14.x
            (fs.rmSync || fs.rmdirSync)(this.cacheDir, { recursive: true });
        }
        fs.mkdirSync(this.cacheDir, { recursive: true });
        let fileNameIndex = 0;
        let fileName = null;
        for (let group of groupedEndpoints) {
            const content = await yaml.dump(group, {
                schema: yaml.JSON_SCHEMA,
                skipInvalid: true,
                noRefs: true,
            });
            if (Object.keys(groupFileNames).length == groupedEndpoints.length
                && groupFileNames[group.name]) {
                fileName = groupFileNames[group.name];
            }
            else {
                // Format numbers as two digits so they are sorted properly when retrieving later
                // (ie "10.yaml" comes after "9.yaml", not after "1.yaml")
                fileName = String(fileNameIndex).padStart(2, '0') + ".yaml";
                fileNameIndex++;
            }
            fs.writeFileSync(`${this.camelDir}/${fileName}`, content);
            fs.writeFileSync(`${this.cacheDir}/${fileName}`, "## Autogenerated by Scribe. DO NOT MODIFY.\n\n" + content);
        }
    },
    groupEndpoints(parsedEndpoints, endpointGroupIndexes) {
        const groups = groupBy(parsedEndpoints, 'metadata.groupName');
        return Object.entries(groups).map(([groupName, endpointsInGroup]) => {
            var _a, _b;
            let sortedEndpoints = endpointsInGroup;
            if (Object.keys(endpointGroupIndexes).length) {
                sortedEndpoints = sortBy(endpointsInGroup, (e) => { var _a; return (_a = endpointGroupIndexes[e.endpointId]) !== null && _a !== void 0 ? _a : Math.max; });
            }
            return {
                name: groupName,
                description: (_b = (_a = endpointsInGroup.find(e => { var _a; return ((_a = e.metadata) === null || _a === void 0 ? void 0 : _a.groupDescription) != null; })) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.groupDescription,
                endpoints: sortedEndpoints.map(e => e.forSerialisation()),
            };
        });
    },
    writeExampleCustomEndpoint() {
        // We add an example to guide users in case they need to add a custom endpoint.
        if (!fs.existsSync(this.camelDir + '/custom.0.yaml')) {
            fs.copyFileSync(__dirname + '/../../resources/example_custom_endpoint.yaml', this.camelDir + '/custom.0.yaml');
        }
    },
    prepareGroupedEndpointsForOutput(groupedEndpoints) {
        const groups = groupedEndpoints.map((group) => {
            var _a;
            return {
                name: group.name,
                description: group.description,
                fileName: (_a = groupFileNames[group.name]) !== null && _a !== void 0 ? _a : null,
                endpoints: group.endpoints.map(endpoint => OutputEndpointData.fromExtractedEndpointObject(endpoint)),
            };
        });
        return sortBy(groups, 'fileName');
    },
    loadEndpointsIntoGroups(folder) {
        let groups = [];
        loadEndpointsFromCamelFiles(folder, (group) => {
            group.endpoints = group.endpoints.map((endpoint) => {
                return OutputEndpointData.fromExtractedEndpointObject(endpoint);
            });
            groups.push(group);
        });
        return groups;
    },
    loadUserDefinedEndpoints(folder) {
        let userDefinedEndpoints = [];
        const contents = fs.readdirSync(folder);
        contents.forEach(fileName => {
            if (fileName.endsWith('.yaml') && fileName.startsWith('custom.')) {
                const endpoints = yaml.load(fs.readFileSync(folder + '/' + fileName));
                (endpoints !== null && endpoints !== void 0 ? endpoints : []).forEach(endpoint => {
                    userDefinedEndpoints.push(endpoint);
                });
            }
        });
        return userDefinedEndpoints;
    },
    /**
     * Load endpoints from the Camel files into a flat list of plain endpoint objects
     */
    loadEndpointsToFlatPrimitivesArray(folder, isFromCache = false) {
        const endpoints = [];
        loadEndpointsFromCamelFiles(folder, (group) => {
            group.endpoints.forEach(endpoint => {
                endpoints.push(endpoint);
            });
        }, !isFromCache);
        return endpoints;
    },
    getEndpointIndexInGroup(groups, endpoint) {
        for (let group of groups) {
            for (let [index, endpointInGroup] of group.endpoints.entries()) {
                if (endpointInGroup.endpointId === endpoint.endpointId) {
                    return index;
                }
            }
        }
        return null;
    }
};
//# sourceMappingURL=camel.js.map